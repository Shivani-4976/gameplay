<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Chrome Dino Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
        }
        
        #game-container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #score-display {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 24px;
            color: #333;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 10px 15px;
            border-radius: 5px;
        }
        
        #menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        
        .menu-title {
            font-size: 48px;
            margin-bottom: 30px;
            color: #ffcc00;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .menu-button {
            background-color: #ffcc00;
            color: #333;
            border: none;
            padding: 15px 30px;
            margin: 10px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
        }
        
        .menu-button:hover {
            background-color: #ffdd33;
            transform: scale(1.05);
        }
        
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        
        #powerup-indicator {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 18px;
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 5px;
            display: none;
        }
        
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: none;
            justify-content: space-around;
            pointer-events: auto;
        }
        
        .mobile-btn {
            background-color: rgba(255, 255, 255, 0.3);
            color: white;
            border: none;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }
        
        @media (max-width: 768px) {
            #mobile-controls {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <div id="ui-container">
        <div id="score-display">Score: 0</div>
        <div id="powerup-indicator"></div>
        
        <div id="mobile-controls">
            <button class="mobile-btn" id="jump-btn">↑</button>
            <button class="mobile-btn" id="duck-btn">↓</button>
        </div>
        
        <div id="menu-screen">
            <h1 class="menu-title">3D CHROME DINO</h1>
            <button class="menu-button" id="start-classic">Classic Mode</button>
            <button class="menu-button" id="start-endless">Endless Mode</button>
            <button class="menu-button" id="start-timetrial">Time Trial</button>
            <button class="menu-button" id="settings-btn">Settings</button>
            <div id="high-score-display" style="margin-top: 20px;">High Score: 0</div>
        </div>
        
        <div id="game-over-screen">
            <h1 class="menu-title">GAME OVER</h1>
            <div id="final-score" style="font-size: 24px; margin-bottom: 20px;">Score: 0</div>
            <button class="menu-button" id="restart-btn">Play Again</button>
            <button class="menu-button" id="menu-btn">Main Menu</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <script>
        // Game Constants
        const GAME_SPEED_START = 0.05;
        const GAME_SPEED_INCREMENT = 0.0001;
        const GRAVITY = 0.002;
        const JUMP_FORCE = 0.015;
        const DINO_FRAME_TIME = 100;
        const OBSTACLE_INTERVAL_MIN = 1000;
        const OBSTACLE_INTERVAL_MAX = 2000;
        const CLOUD_INTERVAL = 3000;
        const DAY_NIGHT_CYCLE = 60000; // 1 minute cycle
        const POWERUP_DURATION = 10000; // 10 seconds
        
        // Game Variables
        let scene, camera, renderer, composer, bloomPass;
        let dino, ground, obstacles = [], clouds = [], powerups = [];
        let gameSpeed = GAME_SPEED_START;
        let score = 0;
        let highScore = localStorage.getItem('highScore') || 0;
        let isJumping = false;
        let isDucking = false;
        let isGameOver = false;
        let isGameStarted = false;
        let gameMode = 'classic';
        let dinoVelocity = 0;
        let lastObstacleTime = 0;
        let lastCloudTime = 0;
        let obstacleInterval = OBSTACLE_INTERVAL_MAX;
        let dayNightProgress = 0;
        let powerupActive = null;
        let powerupEndTime = 0;
        let coinsCollected = 0;
        let clock = new THREE.Clock();
        
        // Initialize the game
        function init() {
            // Set up Three.js scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf7f7f7);
            
            // Set up camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);
            camera.lookAt(0, 1, 0);
            
            // Set up renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Post-processing for bloom effect
            const renderScene = new THREE.RenderPass(scene, camera);
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, 0.4, 0.85
            );
            bloomPass.threshold = 0;
            bloomPass.strength = 1;
            bloomPass.radius = 0.5;
            
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);
            
            // Add hemisphere light for more natural lighting
            const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.3);
            scene.add(hemisphereLight);
            
            // Create ground
            createGround();
            
            // Create dinosaur
            createDino();
            
            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Mobile controls
            document.getElementById('jump-btn').addEventListener('touchstart', () => jump());
            document.getElementById('duck-btn').addEventListener('touchstart', () => duck(true));
            document.getElementById('duck-btn').addEventListener('touchend', () => duck(false));
            
            // Menu buttons
            document.getElementById('start-classic').addEventListener('click', () => startGame('classic'));
            document.getElementById('start-endless').addEventListener('click', () => startGame('endless'));
            document.getElementById('start-timetrial').addEventListener('click', () => startGame('timetrial'));
            document.getElementById('restart-btn').addEventListener('click', restartGame);
            document.getElementById('menu-btn').addEventListener('click', showMenu);
            
            // Update high score display
            document.getElementById('high-score-display').textContent = `High Score: ${highScore}`;
            
            // Start animation loop
            animate();
        }
        
        function createGround() {
            // Create a long ground plane
            const groundGeometry = new THREE.PlaneGeometry(100, 10);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.8,
                metalness: 0.2
            });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.5;
            ground.position.z = -20;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add some variation to the ground
            for (let i = 0; i < 20; i++) {
                const rockGeometry = new THREE.SphereGeometry(0.1 + Math.random() * 0.2, 8, 8);
                const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x777777 });
                const rock = new THREE.Mesh(rockGeometry, rockMaterial);
                rock.position.set(
                    Math.random() * 80 - 40,
                    -0.4,
                    Math.random() * 100 - 70
                );
                rock.castShadow = true;
                scene.add(rock);
            }
        }
        
        function createDino() {
            // Create a more visible dinosaur model
            const bodyGeometry = new THREE.BoxGeometry(0.8, 0.5, 1.2);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            
            const headGeometry = new THREE.BoxGeometry(0.5, 0.3, 0.5);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0.5, 0.7, 0);
            head.castShadow = true;
            
            // Add eyes to make it more visible
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.6, 0.8, 0.15);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.6, 0.8, -0.15);
            
            // Add pupils
            const pupilGeometry = new THREE.SphereGeometry(0.02, 8, 8);
            const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.set(0.62, 0.8, 0.15);
            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.set(0.62, 0.8, -0.15);
            
            const leg1Geometry = new THREE.BoxGeometry(0.2, 0.4, 0.2);
            const leg1Material = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const leg1 = new THREE.Mesh(leg1Geometry, leg1Material);
            leg1.position.set(-0.3, 0, 0.3);
            leg1.castShadow = true;
            
            const leg2Geometry = new THREE.BoxGeometry(0.2, 0.4, 0.2);
            const leg2Material = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const leg2 = new THREE.Mesh(leg2Geometry, leg2Material);
            leg2.position.set(0.3, 0, 0.3);
            leg2.castShadow = true;
            
            const leg3Geometry = new THREE.BoxGeometry(0.2, 0.4, 0.2);
            const leg3Material = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const leg3 = new THREE.Mesh(leg3Geometry, leg3Material);
            leg3.position.set(-0.3, 0, -0.3);
            leg3.castShadow = true;
            
            const leg4Geometry = new THREE.BoxGeometry(0.2, 0.4, 0.2);
            const leg4Material = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const leg4 = new THREE.Mesh(leg4Geometry, leg4Material);
            leg4.position.set(0.3, 0, -0.3);
            leg4.castShadow = true;
            
            const tailGeometry = new THREE.BoxGeometry(0.1, 0.2, 0.8);
            const tailMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.set(-0.6, 0.4, 0);
            tail.rotation.z = -0.3;
            tail.castShadow = true;
            
            dino = new THREE.Group();
            dino.add(body);
            dino.add(head);
            dino.add(leftEye);
            dino.add(rightEye);
            dino.add(leftPupil);
            dino.add(rightPupil);
            dino.add(leg1);
            dino.add(leg2);
            dino.add(leg3);
            dino.add(leg4);
            dino.add(tail);
            
            dino.position.set(-2, 0, 0);
            dino.castShadow = true;
            scene.add(dino);
            
            // Make dinosaur more visible with emissive material
            bodyMaterial.emissive = new THREE.Color(0x111111);
            bodyMaterial.emissiveIntensity = 0.2;
            headMaterial.emissive = new THREE.Color(0x111111);
            headMaterial.emissiveIntensity = 0.2;
        }
        
        function createObstacle() {
            const types = ['cactus', 'cactus', 'cactus', 'rock', 'bird'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            let obstacle;
            
            switch(type) {
                case 'cactus':
                    const cactusHeight = 0.5 + Math.random() * 0.5;
                    const cactusGeometry = new THREE.CylinderGeometry(0.1, 0.1, cactusHeight, 6);
                    const cactusMaterial = new THREE.MeshStandardMaterial({ color: 0x00aa00 });
                    obstacle = new THREE.Mesh(cactusGeometry, cactusMaterial);
                    obstacle.position.y = cactusHeight / 2;
                    break;
                    
                case 'rock':
                    const rockSize = 0.3 + Math.random() * 0.3;
                    const rockGeometry = new THREE.SphereGeometry(rockSize, 8, 8);
                    const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x777777 });
                    obstacle = new THREE.Mesh(rockGeometry, rockMaterial);
                    obstacle.position.y = rockSize;
                    break;
                    
                case 'bird':
                    // Simple bird geometry (would be better with a proper model)
                    const bodyGeometry = new THREE.SphereGeometry(0.2);
                    const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xaa0000 });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    
                    const wingGeometry = new THREE.BoxGeometry(0.4, 0.05, 0.2);
                    const wingMaterial = new THREE.MeshStandardMaterial({ color: 0xaa0000 });
                    const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                    leftWing.position.set(-0.2, 0, 0);
                    const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                    rightWing.position.set(0.2, 0, 0);
                    
                    obstacle = new THREE.Group();
                    obstacle.add(body);
                    obstacle.add(leftWing);
                    obstacle.add(rightWing);
                    obstacle.position.y = 1.5;
                    break;
            }
            
            obstacle.position.z = -30;
            obstacle.castShadow = true;
            obstacle.userData = { type, passed: false };
            scene.add(obstacle);
            obstacles.push(obstacle);
            
            // Random chance to spawn a powerup after this obstacle
            if (Math.random() < 0.2) {
                setTimeout(createPowerup, 1000);
            }
        }
        
        function createPowerup() {
            const types = ['speed', 'invincible', 'score'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            let powerup;
            let color;
            
            switch(type) {
                case 'speed':
                    color = 0x00ffff;
                    break;
                case 'invincible':
                    color = 0xffff00;
                    break;
                case 'score':
                    color = 0xff00ff;
                    break;
            }
            
            const geometry = new THREE.SphereGeometry(0.2, 16, 16);
            const material = new THREE.MeshStandardMaterial({ 
                color,
                emissive: color,
                emissiveIntensity: 0.5,
                metalness: 0.7,
                roughness: 0.2
            });
            
            powerup = new THREE.Mesh(geometry, material);
            powerup.position.set(Math.random() * 4 - 2, 1, -30);
            powerup.castShadow = true;
            powerup.userData = { type };
            
            // Add pulsing animation
            powerup.userData.pulseSpeed = 0.02 + Math.random() * 0.02;
            powerup.userData.originalY = powerup.position.y;
            
            scene.add(powerup);
            powerups.push(powerup);
        }
        
        function createCloud() {
            const cloudSize = 0.5 + Math.random();
            const segments = Math.floor(3 + Math.random() * 3);
            
            const cloud = new THREE.Group();
            
            for (let i = 0; i < segments; i++) {
                const segmentSize = cloudSize * (0.5 + Math.random() * 0.5);
                const geometry = new THREE.SphereGeometry(segmentSize, 8, 8);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                const segment = new THREE.Mesh(geometry, material);
                segment.position.set(
                    (Math.random() - 0.5) * cloudSize * 2,
                    (Math.random() - 0.5) * cloudSize,
                    (Math.random() - 0.5) * cloudSize
                );
                cloud.add(segment);
            }
            
            cloud.position.set(
                Math.random() * 10 - 5,
                3 + Math.random() * 3,
                -30 - Math.random() * 20
            );
            
            cloud.userData = { speed: 0.01 + Math.random() * 0.02 };
            scene.add(cloud);
            clouds.push(cloud);
        }
        
        function startGame(mode) {
            gameMode = mode;
            isGameStarted = true;
            isGameOver = false;
            score = 0;
            gameSpeed = GAME_SPEED_START;
            obstacleInterval = OBSTACLE_INTERVAL_MAX;
            
            // Reset dino position
            dino.position.y = 0;
            dino.rotation.x = 0;
            dino.scale.set(1, 1, 1);
            
            // Clear obstacles
            obstacles.forEach(obstacle => scene.remove(obstacle));
            obstacles = [];
            
            // Clear powerups
            powerups.forEach(powerup => scene.remove(powerup));
            powerups = [];
            
            // Clear clouds
            clouds.forEach(cloud => scene.remove(cloud));
            clouds = [];
            
            // Hide menu
            document.getElementById('menu-screen').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            
            // Reset camera
            camera.position.set(0, 2, 5);
            camera.lookAt(0, 1, 0);
            
            // Start game loop
            lastObstacleTime = Date.now();
            lastCloudTime = Date.now();
        }
        
        function restartGame() {
            document.getElementById('game-over-screen').style.display = 'none';
            startGame(gameMode);
        }
        
        function showMenu() {
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('menu-screen').style.display = 'flex';
            isGameStarted = false;
        }
        
        function gameOver() {
            isGameOver = true;
            isGameStarted = false;
            
            // Update high score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
                document.getElementById('high-score-display').textContent = `High Score: ${highScore}`;
            }
            
            // Show game over screen
            document.getElementById('final-score').textContent = `Score: ${Math.floor(score)}`;
            document.getElementById('game-over-screen').style.display = 'flex';
            
            // Dino death animation
            gsap.to(dino.rotation, {
                x: Math.PI / 2,
                duration: 0.5
            });
            gsap.to(dino.position, {
                y: 0.5,
                duration: 0.5
            });
        }
        
        function jump() {
            if (!isJumping && isGameStarted && !isGameOver) {
                isJumping = true;
                dinoVelocity = JUMP_FORCE;
                
                // Simple jump animation
                gsap.to(dino.rotation, {
                    x: -0.2,
                    duration: 0.2
                });
            }
        }
        
        function duck(isDucking) {
            if (!isJumping && isGameStarted && !isGameOver) {
                this.isDucking = isDucking;
                
                if (isDucking) {
                    // Duck animation
                    gsap.to(dino.scale, {
                        y: 0.5,
                        duration: 0.2
                    });
                    gsap.to(dino.position, {
                        y: -0.25,
                        duration: 0.2
                    });
                } else {
                    // Stand up animation
                    gsap.to(dino.scale, {
                        y: 1,
                        duration: 0.2
                    });
                    gsap.to(dino.position, {
                        y: 0,
                        duration: 0.2
                    });
                }
            }
        }
        
        function update() {
            if (!isGameStarted) return;
            
            const deltaTime = clock.getDelta();
            dayNightProgress = (dayNightProgress + deltaTime * 1000 / DAY_NIGHT_CYCLE) % 1;
            
            // Update day/night cycle
            updateDayNightCycle();
            
            // Update score and difficulty
            score += gameSpeed * 10;
            document.getElementById('score-display').textContent = `Score: ${Math.floor(score)}`;
            
            if (gameMode === 'endless') {
                gameSpeed += GAME_SPEED_INCREMENT;
                obstacleInterval = Math.max(
                    OBSTACLE_INTERVAL_MIN, 
                    OBSTACLE_INTERVAL_MAX - score * 0.01
                );
            }
            
            // Spawn obstacles
            const now = Date.now();
            if (now - lastObstacleTime > obstacleInterval) {
                createObstacle();
                lastObstacleTime = now;
            }
            
            // Spawn clouds
            if (now - lastCloudTime > CLOUD_INTERVAL) {
                createCloud();
                lastCloudTime = now;
            }
            
            // Update dino position (jumping/falling)
            if (isJumping) {
                dino.position.y += dinoVelocity;
                dinoVelocity -= GRAVITY;
                
                if (dino.position.y <= 0) {
                    dino.position.y = 0;
                    isJumping = false;
                    dinoVelocity = 0;
                    
                    // Landing animation
                    gsap.to(dino.rotation, {
                        x: 0,
                        duration: 0.2
                    });
                }
            }
            
            // Update obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                obstacle.position.z += gameSpeed;
                
                // Check if obstacle passed the dino
                if (obstacle.position.z > 0 && !obstacle.userData.passed) {
                    obstacle.userData.passed = true;
                    
                    // Small chance to spawn a coin
                    if (Math.random() < 0.1) {
                        createCoin(obstacle.position.x, obstacle.position.y + 0.5, obstacle.position.z);
                    }
                }
                
                // Check collision
                if (!isGameOver && checkCollision(dino, obstacle)) {
                    if (powerupActive === 'invincible') {
                        // Destroy obstacle when invincible
                        scene.remove(obstacle);
                        obstacles.splice(i, 1);
                        
                        // Screen shake effect
                        gsap.to(camera.position, {
                            x: camera.position.x + (Math.random() - 0.5) * 0.3,
                            y: camera.position.y + (Math.random() - 0.5) * 0.3,
                            duration: 0.1,
                            repeat: 5,
                            yoyo: true
                        });
                    } else {
                        gameOver();
                        break;
                    }
                }
                
                // Remove obstacles that are far behind
                if (obstacle.position.z > 30) {
                    scene.remove(obstacle);
                    obstacles.splice(i, 1);
                }
            }
            
            // Update powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                powerup.position.z += gameSpeed;
                
                // Pulsing animation
                if (powerup.userData.originalY !== undefined) {
                    powerup.position.y = powerup.userData.originalY + Math.sin(Date.now() * powerup.userData.pulseSpeed) * 0.2;
                }
                powerup.rotation.y += 0.05;
                
                // Check collection
                if (checkCollision(dino, powerup)) {
                    activatePowerup(powerup.userData.type);
                    scene.remove(powerup);
                    powerups.splice(i, 1);
                }
                
                // Remove powerups that are far behind
                if (powerup.position.z > 30) {
                    scene.remove(powerup);
                    powerups.splice(i, 1);
                }
            }
            
            // Update clouds
            for (let i = clouds.length - 1; i >= 0; i--) {
                const cloud = clouds[i];
                cloud.position.z += gameSpeed * cloud.userData.speed;
                
                // Remove clouds that are far behind
                if (cloud.position.z > 30) {
                    scene.remove(cloud);
                    clouds.splice(i, 1);
                }
            }
            
            // Update active powerup
            if (powerupActive && Date.now() > powerupEndTime) {
                deactivatePowerup();
            }
            
            // Simple running animation
            if (!isJumping && !isDucking) {
                const leg1 = dino.children[6]; // leg1
                const leg2 = dino.children[7]; // leg2
                const leg3 = dino.children[8]; // leg3
                const leg4 = dino.children[9]; // leg4
                
                const legAngle = Math.sin(Date.now() * 0.01) * 0.5;
                leg1.rotation.x = legAngle;
                leg2.rotation.x = -legAngle;
                leg3.rotation.x = -legAngle;
                leg4.rotation.x = legAngle;
            }
            
            // Camera follow with slight delay
            camera.position.x += (dino.position.x - camera.position.x) * 0.1;
            
            // Occasionally change camera angle for dramatic effect
            if (Math.random() < 0.001) {
                const angle = Math.random() * Math.PI * 0.1 - Math.PI * 0.05;
                gsap.to(camera.rotation, {
                    y: angle,
                    duration: 1,
                    onComplete: () => {
                        gsap.to(camera.rotation, {
                            y: 0,
                            duration: 1
                        });
                    }
                });
            }
        }
        
        function updateDayNightCycle() {
            // Update lighting based on day/night cycle
            const ambientIntensity = 0.3 + 0.2 * Math.sin(dayNightProgress * Math.PI * 2);
            scene.children.forEach(child => {
                if (child instanceof THREE.AmbientLight) {
                    child.intensity = ambientIntensity;
                }
            });
            
            // Change sky color slightly
            const skyColor = new THREE.Color().setHSL(
                0.6, 
                0.1, 
                0.7 + 0.2 * Math.sin(dayNightProgress * Math.PI * 2)
            );
            scene.background = skyColor;
        }
        
        function activatePowerup(type) {
            powerupActive = type;
            powerupEndTime = Date.now() + POWERUP_DURATION;
            
            let message = '';
            let color = '';
            
            switch(type) {
                case 'speed':
                    gameSpeed *= 1.5;
                    message = 'SPEED BOOST!';
                    color = '#0ff';
                    break;
                case 'invincible':
                    message = 'INVINCIBLE!';
                    color = '#ff0';
                    break;
                case 'score':
                    message = 'SCORE x2!';
                    color = '#f0f';
                    break;
            }
            
            // Show powerup indicator
            const indicator = document.getElementById('powerup-indicator');
            indicator.textContent = message;
            indicator.style.color = color;
            indicator.style.display = 'block';
            
            // Visual effect
            bloomPass.strength = 2;
            setTimeout(() => {
                bloomPass.strength = 1;
            }, 500);
        }
        
        function deactivatePowerup() {
            if (powerupActive === 'speed') {
                gameSpeed /= 1.5;
            }
            
            powerupActive = null;
            document.getElementById('powerup-indicator').style.display = 'none';
        }
        
        function createCoin(x, y, z) {
            const coinGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 32);
            const coinMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700,
                metalness: 0.9,
                roughness: 0.1
            });
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.rotation.x = Math.PI / 2;
            coin.position.set(x, y, z);
            coin.userData = { spinSpeed: 0.05 };
            scene.add(coin);
            powerups.push(coin); // Reusing powerups array for coins
        }
        
        function checkCollision(obj1, obj2) {
            // Simple AABB collision detection
            const box1 = new THREE.Box3().setFromObject(obj1);
            const box2 = new THREE.Box3().setFromObject(obj2);
            
            // Adjust box sizes for better gameplay feel
            box1.min.y += 0.2; // Make hitbox smaller vertically
            box1.max.y -= 0.2;
            
            if (obj2.userData && obj2.userData.type === 'bird') {
                box2.min.y -= 0.3; // Make bird hitbox larger
                box2.max.y += 0.3;
            }
            
            return box1.intersectsBox(box2);
        }
        
        function onKeyDown(event) {
            switch(event.keyCode) {
                case 32: // Space
                case 38: // Up arrow
                    jump();
                    break;
                case 40: // Down arrow
                    duck(true);
                    break;
            }
        }
        
        function onKeyUp(event) {
            if (event.keyCode === 40) { // Down arrow
                duck(false);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            update();
            composer.render();
        }
        
        // Start the game
        init();
        
        // Simple GSAP implementation for animations (would normally include GSAP library)
        const gsap = {
            to: function(target, params) {
                const startValues = {};
                const endValues = {};
                const duration = params.duration || 1;
                const ease = params.ease || "linear";
                
                for (const prop in params) {
                    if (prop !== 'duration' && prop !== 'ease' && prop !== 'onComplete' && prop !== 'repeat' && prop !== 'yoyo') {
                        if (target[prop] !== undefined) {
                            startValues[prop] = target[prop];
                            endValues[prop] = params[prop];
                        }
                    }
                }
                
                const startTime = Date.now();
                const endTime = startTime + duration * 1000;
                
                function updateAnimation() {
                    const now = Date.now();
                    const progress = Math.min(1, (now - startTime) / (duration * 1000));
                    let easedProgress;
                    
                    switch(ease) {
                        case "power1.out":
                            easedProgress = 1 - Math.pow(1 - progress, 1);
                            break;
                        case "power2.out":
                            easedProgress = 1 - Math.pow(1 - progress, 2);
                            break;
                        default: // linear
                            easedProgress = progress;
                    }
                    
                    for (const prop in startValues) {
                        if (Array.isArray(startValues[prop])) {
                            target[prop] = startValues[prop].map((val, i) => 
                                val + (endValues[prop][i] - val) * easedProgress
                            );
                        } else {
                            target[prop] = startValues[prop] + (endValues[prop] - startValues[prop]) * easedProgress;
                        }
                    }
                    
                    if (now < endTime) {
                        requestAnimationFrame(updateAnimation);
                    } else {
                        if (params.onComplete) params.onComplete();
                        if (params.repeat) {
                            // Simple repeat logic
                            setTimeout(() => {
                                gsap.to(target, params);
                            }, 100);
                        } else if (params.yoyo) {
                            // Simple yoyo logic
                            const reverseParams = {...params};
                            for (const prop in startValues) {
                                reverseParams[prop] = startValues[prop];
                            }
                            delete reverseParams.yoyo;
                            setTimeout(() => {
                                gsap.to(target, reverseParams);
                            }, 100);
                        }
                    }
                }
                
                updateAnimation();
            }
        };
    </script>
</body>
</html>
